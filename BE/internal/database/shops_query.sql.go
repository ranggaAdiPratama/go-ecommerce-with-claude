// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: shops_query.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteShop = `-- name: DeleteShop :exec
UPDATE shops SET deleted_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteShop(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteShop, id)
	return err
}

const getDeletedShopById = `-- name: GetDeletedShopById :one
SELECT id, user_id, name, logo, rank, created_at, updated_at, deleted_at
FROM shops
WHERE
    id = $1
    AND deleted_at IS NOT NULL
LIMIT 1
`

func (q *Queries) GetDeletedShopById(ctx context.Context, id uuid.UUID) (Shop, error) {
	row := q.db.QueryRowContext(ctx, getDeletedShopById, id)
	var i Shop
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Logo,
		&i.Rank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getShopById = `-- name: GetShopById :one
SELECT id, user_id, name, logo, rank, created_at, updated_at, deleted_at
FROM shops
WHERE
    id = $1
    AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetShopById(ctx context.Context, id uuid.UUID) (Shop, error) {
	row := q.db.QueryRowContext(ctx, getShopById, id)
	var i Shop
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Logo,
		&i.Rank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getShopByName = `-- name: GetShopByName :one
SELECT id, user_id, name, logo, rank, created_at, updated_at, deleted_at
FROM shops
WHERE
    name = $1
    AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetShopByName(ctx context.Context, name string) (Shop, error) {
	row := q.db.QueryRowContext(ctx, getShopByName, name)
	var i Shop
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Logo,
		&i.Rank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getShopByUserId = `-- name: GetShopByUserId :one
SELECT id, user_id, name, logo, rank, created_at, updated_at, deleted_at
FROM shops
WHERE
    user_id = $1
    AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetShopByUserId(ctx context.Context, userID uuid.UUID) (Shop, error) {
	row := q.db.QueryRowContext(ctx, getShopByUserId, userID)
	var i Shop
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Logo,
		&i.Rank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const shopList = `-- name: ShopList :many
SELECT id, user_id, name, logo, rank, created_at, updated_at, deleted_at FROM shops
WHERE
    deleted_at IS NULL
     AND (
        NULLIF($1::text, '') IS NULL
        OR rank = $1::text
    )
    AND (
        NULLIF($2::text, '') IS NULL
        OR name ~* $2::text
    )
ORDER BY
    CASE
        WHEN $3::text = 'name' AND $4::text = 'asc' THEN name
    END ASC,
    CASE
        WHEN $3::text = 'name' AND $4::text = 'desc' THEN name
    END DESC,
    CASE
        WHEN $3::text = 'created_at' AND $4::text = 'asc' THEN created_at
    END ASC,
    CASE
        WHEN $3::text = 'created_at' AND $4::text = 'desc' THEN created_at
    END DESC,
    name DESC
LIMIT COALESCE($6::int, 15)
OFFSET COALESCE($5::int, 0)
`

type ShopListParams struct {
	Rank      string `json:"rank"`
	Search    string `json:"search"`
	Sort      string `json:"sort"`
	SortOrder string `json:"sort_order"`
	Page      int32  `json:"page"`
	Till      int32  `json:"till"`
}

func (q *Queries) ShopList(ctx context.Context, arg ShopListParams) ([]Shop, error) {
	rows, err := q.db.QueryContext(ctx, shopList,
		arg.Rank,
		arg.Search,
		arg.Sort,
		arg.SortOrder,
		arg.Page,
		arg.Till,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Shop{}
	for rows.Next() {
		var i Shop
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Logo,
			&i.Rank,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const shopListTotal = `-- name: ShopListTotal :one
SELECT COUNT(*) AS total
FROM shops
WHERE
    deleted_at IS NULL
     AND (
        NULLIF($1::text, '') IS NULL
        OR rank = $1::text
    )
    AND (
        NULLIF($2::text, '') IS NULL
        OR name ~* $2::text
    )
`

type ShopListTotalParams struct {
	Rank   string `json:"rank"`
	Search string `json:"search"`
}

func (q *Queries) ShopListTotal(ctx context.Context, arg ShopListTotalParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, shopListTotal, arg.Rank, arg.Search)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const storeShop = `-- name: StoreShop :one
INSERT INTO
    shops (
        user_id,
        name,
        logo,
        created_at,
        updated_at
    )
VALUES ($1, $2, $3, NOw(), NOW()) RETURNING id,
    user_id,
    name,
    logo,
    rank,
    created_at,
    updated_at
`

type StoreShopParams struct {
	UserID uuid.UUID `json:"user_id"`
	Name   string    `json:"name"`
	Logo   string    `json:"logo"`
}

type StoreShopRow struct {
	ID        uuid.UUID `json:"id"`
	UserID    uuid.UUID `json:"user_id"`
	Name      string    `json:"name"`
	Logo      string    `json:"logo"`
	Rank      string    `json:"rank"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) StoreShop(ctx context.Context, arg StoreShopParams) (StoreShopRow, error) {
	row := q.db.QueryRowContext(ctx, storeShop, arg.UserID, arg.Name, arg.Logo)
	var i StoreShopRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Logo,
		&i.Rank,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateShop = `-- name: UpdateShop :one
UPDATE shops
SET
    name = COALESCE(NULLIF($1::text, ''), name),
    logo = COALESCE(
        NULLIF($2::text, ''),
        logo
    ),
    rank = COALESCE(
        NULLIF($3::text, ''),
        rank
    ),
    updated_at = NOW()
WHERE
    id = $4 RETURNING id,
    user_id,
    name,
    logo,
    rank,
    created_at,
    updated_at
`

type UpdateShopParams struct {
	Name string    `json:"name"`
	Logo string    `json:"logo"`
	Rank string    `json:"rank"`
	ID   uuid.UUID `json:"id"`
}

type UpdateShopRow struct {
	ID        uuid.UUID `json:"id"`
	UserID    uuid.UUID `json:"user_id"`
	Name      string    `json:"name"`
	Logo      string    `json:"logo"`
	Rank      string    `json:"rank"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateShop(ctx context.Context, arg UpdateShopParams) (UpdateShopRow, error) {
	row := q.db.QueryRowContext(ctx, updateShop,
		arg.Name,
		arg.Logo,
		arg.Rank,
		arg.ID,
	)
	var i UpdateShopRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Logo,
		&i.Rank,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
